// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'course_teacher_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$CourseTeacherEventTearOff {
  const _$CourseTeacherEventTearOff();

  _FetchCourses fetchCourses() {
    return const _FetchCourses();
  }

  _RefreshCourses refreshCourses() {
    return const _RefreshCourses();
  }

  _OnLoggedOut onLoggedOut() {
    return const _OnLoggedOut();
  }
}

// ignore: unused_element
const $CourseTeacherEvent = _$CourseTeacherEventTearOff();

mixin _$CourseTeacherEvent {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result fetchCourses(),
    @required Result refreshCourses(),
    @required Result onLoggedOut(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result fetchCourses(),
    Result refreshCourses(),
    Result onLoggedOut(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result fetchCourses(_FetchCourses value),
    @required Result refreshCourses(_RefreshCourses value),
    @required Result onLoggedOut(_OnLoggedOut value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result fetchCourses(_FetchCourses value),
    Result refreshCourses(_RefreshCourses value),
    Result onLoggedOut(_OnLoggedOut value),
    @required Result orElse(),
  });
}

abstract class $CourseTeacherEventCopyWith<$Res> {
  factory $CourseTeacherEventCopyWith(
          CourseTeacherEvent value, $Res Function(CourseTeacherEvent) then) =
      _$CourseTeacherEventCopyWithImpl<$Res>;
}

class _$CourseTeacherEventCopyWithImpl<$Res>
    implements $CourseTeacherEventCopyWith<$Res> {
  _$CourseTeacherEventCopyWithImpl(this._value, this._then);

  final CourseTeacherEvent _value;
  // ignore: unused_field
  final $Res Function(CourseTeacherEvent) _then;
}

abstract class _$FetchCoursesCopyWith<$Res> {
  factory _$FetchCoursesCopyWith(
          _FetchCourses value, $Res Function(_FetchCourses) then) =
      __$FetchCoursesCopyWithImpl<$Res>;
}

class __$FetchCoursesCopyWithImpl<$Res>
    extends _$CourseTeacherEventCopyWithImpl<$Res>
    implements _$FetchCoursesCopyWith<$Res> {
  __$FetchCoursesCopyWithImpl(
      _FetchCourses _value, $Res Function(_FetchCourses) _then)
      : super(_value, (v) => _then(v as _FetchCourses));

  @override
  _FetchCourses get _value => super._value as _FetchCourses;
}

class _$_FetchCourses implements _FetchCourses {
  const _$_FetchCourses();

  @override
  String toString() {
    return 'CourseTeacherEvent.fetchCourses()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _FetchCourses);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result fetchCourses(),
    @required Result refreshCourses(),
    @required Result onLoggedOut(),
  }) {
    assert(fetchCourses != null);
    assert(refreshCourses != null);
    assert(onLoggedOut != null);
    return fetchCourses();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result fetchCourses(),
    Result refreshCourses(),
    Result onLoggedOut(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (fetchCourses != null) {
      return fetchCourses();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result fetchCourses(_FetchCourses value),
    @required Result refreshCourses(_RefreshCourses value),
    @required Result onLoggedOut(_OnLoggedOut value),
  }) {
    assert(fetchCourses != null);
    assert(refreshCourses != null);
    assert(onLoggedOut != null);
    return fetchCourses(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result fetchCourses(_FetchCourses value),
    Result refreshCourses(_RefreshCourses value),
    Result onLoggedOut(_OnLoggedOut value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (fetchCourses != null) {
      return fetchCourses(this);
    }
    return orElse();
  }
}

abstract class _FetchCourses implements CourseTeacherEvent {
  const factory _FetchCourses() = _$_FetchCourses;
}

abstract class _$RefreshCoursesCopyWith<$Res> {
  factory _$RefreshCoursesCopyWith(
          _RefreshCourses value, $Res Function(_RefreshCourses) then) =
      __$RefreshCoursesCopyWithImpl<$Res>;
}

class __$RefreshCoursesCopyWithImpl<$Res>
    extends _$CourseTeacherEventCopyWithImpl<$Res>
    implements _$RefreshCoursesCopyWith<$Res> {
  __$RefreshCoursesCopyWithImpl(
      _RefreshCourses _value, $Res Function(_RefreshCourses) _then)
      : super(_value, (v) => _then(v as _RefreshCourses));

  @override
  _RefreshCourses get _value => super._value as _RefreshCourses;
}

class _$_RefreshCourses implements _RefreshCourses {
  const _$_RefreshCourses();

  @override
  String toString() {
    return 'CourseTeacherEvent.refreshCourses()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _RefreshCourses);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result fetchCourses(),
    @required Result refreshCourses(),
    @required Result onLoggedOut(),
  }) {
    assert(fetchCourses != null);
    assert(refreshCourses != null);
    assert(onLoggedOut != null);
    return refreshCourses();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result fetchCourses(),
    Result refreshCourses(),
    Result onLoggedOut(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (refreshCourses != null) {
      return refreshCourses();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result fetchCourses(_FetchCourses value),
    @required Result refreshCourses(_RefreshCourses value),
    @required Result onLoggedOut(_OnLoggedOut value),
  }) {
    assert(fetchCourses != null);
    assert(refreshCourses != null);
    assert(onLoggedOut != null);
    return refreshCourses(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result fetchCourses(_FetchCourses value),
    Result refreshCourses(_RefreshCourses value),
    Result onLoggedOut(_OnLoggedOut value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (refreshCourses != null) {
      return refreshCourses(this);
    }
    return orElse();
  }
}

abstract class _RefreshCourses implements CourseTeacherEvent {
  const factory _RefreshCourses() = _$_RefreshCourses;
}

abstract class _$OnLoggedOutCopyWith<$Res> {
  factory _$OnLoggedOutCopyWith(
          _OnLoggedOut value, $Res Function(_OnLoggedOut) then) =
      __$OnLoggedOutCopyWithImpl<$Res>;
}

class __$OnLoggedOutCopyWithImpl<$Res>
    extends _$CourseTeacherEventCopyWithImpl<$Res>
    implements _$OnLoggedOutCopyWith<$Res> {
  __$OnLoggedOutCopyWithImpl(
      _OnLoggedOut _value, $Res Function(_OnLoggedOut) _then)
      : super(_value, (v) => _then(v as _OnLoggedOut));

  @override
  _OnLoggedOut get _value => super._value as _OnLoggedOut;
}

class _$_OnLoggedOut implements _OnLoggedOut {
  const _$_OnLoggedOut();

  @override
  String toString() {
    return 'CourseTeacherEvent.onLoggedOut()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _OnLoggedOut);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result fetchCourses(),
    @required Result refreshCourses(),
    @required Result onLoggedOut(),
  }) {
    assert(fetchCourses != null);
    assert(refreshCourses != null);
    assert(onLoggedOut != null);
    return onLoggedOut();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result fetchCourses(),
    Result refreshCourses(),
    Result onLoggedOut(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (onLoggedOut != null) {
      return onLoggedOut();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result fetchCourses(_FetchCourses value),
    @required Result refreshCourses(_RefreshCourses value),
    @required Result onLoggedOut(_OnLoggedOut value),
  }) {
    assert(fetchCourses != null);
    assert(refreshCourses != null);
    assert(onLoggedOut != null);
    return onLoggedOut(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result fetchCourses(_FetchCourses value),
    Result refreshCourses(_RefreshCourses value),
    Result onLoggedOut(_OnLoggedOut value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (onLoggedOut != null) {
      return onLoggedOut(this);
    }
    return orElse();
  }
}

abstract class _OnLoggedOut implements CourseTeacherEvent {
  const factory _OnLoggedOut() = _$_OnLoggedOut;
}

class _$CourseTeacherStateTearOff {
  const _$CourseTeacherStateTearOff();

  _Loading loading() {
    return const _Loading();
  }

  _Failure failure() {
    return const _Failure();
  }

  _Loaded loaded(List<Course> courses) {
    return _Loaded(
      courses,
    );
  }
}

// ignore: unused_element
const $CourseTeacherState = _$CourseTeacherStateTearOff();

mixin _$CourseTeacherState {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result loading(),
    @required Result failure(),
    @required Result loaded(List<Course> courses),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result loading(),
    Result failure(),
    Result loaded(List<Course> courses),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result loading(_Loading value),
    @required Result failure(_Failure value),
    @required Result loaded(_Loaded value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result loading(_Loading value),
    Result failure(_Failure value),
    Result loaded(_Loaded value),
    @required Result orElse(),
  });
}

abstract class $CourseTeacherStateCopyWith<$Res> {
  factory $CourseTeacherStateCopyWith(
          CourseTeacherState value, $Res Function(CourseTeacherState) then) =
      _$CourseTeacherStateCopyWithImpl<$Res>;
}

class _$CourseTeacherStateCopyWithImpl<$Res>
    implements $CourseTeacherStateCopyWith<$Res> {
  _$CourseTeacherStateCopyWithImpl(this._value, this._then);

  final CourseTeacherState _value;
  // ignore: unused_field
  final $Res Function(CourseTeacherState) _then;
}

abstract class _$LoadingCopyWith<$Res> {
  factory _$LoadingCopyWith(_Loading value, $Res Function(_Loading) then) =
      __$LoadingCopyWithImpl<$Res>;
}

class __$LoadingCopyWithImpl<$Res>
    extends _$CourseTeacherStateCopyWithImpl<$Res>
    implements _$LoadingCopyWith<$Res> {
  __$LoadingCopyWithImpl(_Loading _value, $Res Function(_Loading) _then)
      : super(_value, (v) => _then(v as _Loading));

  @override
  _Loading get _value => super._value as _Loading;
}

class _$_Loading implements _Loading {
  const _$_Loading();

  @override
  String toString() {
    return 'CourseTeacherState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Loading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result loading(),
    @required Result failure(),
    @required Result loaded(List<Course> courses),
  }) {
    assert(loading != null);
    assert(failure != null);
    assert(loaded != null);
    return loading();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result loading(),
    Result failure(),
    Result loaded(List<Course> courses),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result loading(_Loading value),
    @required Result failure(_Failure value),
    @required Result loaded(_Loaded value),
  }) {
    assert(loading != null);
    assert(failure != null);
    assert(loaded != null);
    return loading(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result loading(_Loading value),
    Result failure(_Failure value),
    Result loaded(_Loaded value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _Loading implements CourseTeacherState {
  const factory _Loading() = _$_Loading;
}

abstract class _$FailureCopyWith<$Res> {
  factory _$FailureCopyWith(_Failure value, $Res Function(_Failure) then) =
      __$FailureCopyWithImpl<$Res>;
}

class __$FailureCopyWithImpl<$Res>
    extends _$CourseTeacherStateCopyWithImpl<$Res>
    implements _$FailureCopyWith<$Res> {
  __$FailureCopyWithImpl(_Failure _value, $Res Function(_Failure) _then)
      : super(_value, (v) => _then(v as _Failure));

  @override
  _Failure get _value => super._value as _Failure;
}

class _$_Failure implements _Failure {
  const _$_Failure();

  @override
  String toString() {
    return 'CourseTeacherState.failure()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Failure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result loading(),
    @required Result failure(),
    @required Result loaded(List<Course> courses),
  }) {
    assert(loading != null);
    assert(failure != null);
    assert(loaded != null);
    return failure();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result loading(),
    Result failure(),
    Result loaded(List<Course> courses),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (failure != null) {
      return failure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result loading(_Loading value),
    @required Result failure(_Failure value),
    @required Result loaded(_Loaded value),
  }) {
    assert(loading != null);
    assert(failure != null);
    assert(loaded != null);
    return failure(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result loading(_Loading value),
    Result failure(_Failure value),
    Result loaded(_Loaded value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (failure != null) {
      return failure(this);
    }
    return orElse();
  }
}

abstract class _Failure implements CourseTeacherState {
  const factory _Failure() = _$_Failure;
}

abstract class _$LoadedCopyWith<$Res> {
  factory _$LoadedCopyWith(_Loaded value, $Res Function(_Loaded) then) =
      __$LoadedCopyWithImpl<$Res>;
  $Res call({List<Course> courses});
}

class __$LoadedCopyWithImpl<$Res> extends _$CourseTeacherStateCopyWithImpl<$Res>
    implements _$LoadedCopyWith<$Res> {
  __$LoadedCopyWithImpl(_Loaded _value, $Res Function(_Loaded) _then)
      : super(_value, (v) => _then(v as _Loaded));

  @override
  _Loaded get _value => super._value as _Loaded;

  @override
  $Res call({
    Object courses = freezed,
  }) {
    return _then(_Loaded(
      courses == freezed ? _value.courses : courses as List<Course>,
    ));
  }
}

class _$_Loaded implements _Loaded {
  const _$_Loaded(this.courses) : assert(courses != null);

  @override
  final List<Course> courses;

  @override
  String toString() {
    return 'CourseTeacherState.loaded(courses: $courses)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Loaded &&
            (identical(other.courses, courses) ||
                const DeepCollectionEquality().equals(other.courses, courses)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(courses);

  @override
  _$LoadedCopyWith<_Loaded> get copyWith =>
      __$LoadedCopyWithImpl<_Loaded>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result loading(),
    @required Result failure(),
    @required Result loaded(List<Course> courses),
  }) {
    assert(loading != null);
    assert(failure != null);
    assert(loaded != null);
    return loaded(courses);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result loading(),
    Result failure(),
    Result loaded(List<Course> courses),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loaded != null) {
      return loaded(courses);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result loading(_Loading value),
    @required Result failure(_Failure value),
    @required Result loaded(_Loaded value),
  }) {
    assert(loading != null);
    assert(failure != null);
    assert(loaded != null);
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result loading(_Loading value),
    Result failure(_Failure value),
    Result loaded(_Loaded value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class _Loaded implements CourseTeacherState {
  const factory _Loaded(List<Course> courses) = _$_Loaded;

  List<Course> get courses;
  _$LoadedCopyWith<_Loaded> get copyWith;
}
